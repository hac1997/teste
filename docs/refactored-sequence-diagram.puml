@startuml RefactoredSequenceDiagram
!theme plain
title Refactored Sequence Diagram - Game Flow (After Dependency Resolution)

participant Player1
participant AtorJogador1
participant TabuleiroService1
participant NetworkService1
participant GameEventHandler1
participant Proxy1
participant Server
participant Proxy2
participant NetworkService2
participant GameEventHandler2
participant TabuleiroService2
participant AtorJogador2
participant Player2

note over AtorJogador1, AtorJogador2 : Both implement GameEventHandler interface

== Game Initialization ==

Player1 -> AtorJogador1: iniciarPartida()
AtorJogador1 -> NetworkService1: iniciarPartida()
NetworkService1 -> Proxy1: iniciarPartida(2)
Proxy1 -> Server: iniciarPartida(2)

Server -> Jogo: iniciarPartida(jogador1, 2)
Jogo -> Partida: create new partida

== Start Game Notifications ==

Partida -> ServerHandler1: iniciarNovaPartida(1)
Partida -> ServerHandler2: iniciarNovaPartida(2)

ServerHandler1 -> Proxy1: iniciarNovaPartida(1)
Proxy1 -> NetworkService1: iniciarNovaPartida(1)
NetworkService1 -> GameEventHandler1: receberSolicitacaoInicio(1)
note right: Uses interface, not direct call
GameEventHandler1 -> AtorJogador1: receberSolicitacaoInicio(1)
AtorJogador1 -> TabuleiroService1: iniciarPartida(1, nome1, nome2)
note right: Service handles game logic independently
TabuleiroService1 --> AtorJogador1: Faixa[] tabuleiro

ServerHandler2 -> Proxy2: iniciarNovaPartida(2)
Proxy2 -> NetworkService2: iniciarNovaPartida(2)
NetworkService2 -> GameEventHandler2: receberSolicitacaoInicio(2)
note right: Clean interface usage
GameEventHandler2 -> AtorJogador2: receberSolicitacaoInicio(2)
AtorJogador2 -> TabuleiroService2: iniciarPartida(2, nome1, nome2)
TabuleiroService2 --> AtorJogador2: Faixa[] tabuleiro

== Player 1 Makes Move ==

Player1 -> AtorJogador1: movimentarPeca(origem, destino)
AtorJogador1 -> TabuleiroService1: calcularMovimento(origem, destino)
note right: Pure game logic, no UI dependencies
TabuleiroService1 -> TabuleiroService1: calcularCaptura(destino)
TabuleiroService1 -> TabuleiroService1: calcularTomadaTrono(destino)
TabuleiroService1 --> AtorJogador1: boolean movimentoValido

alt movimento válido
    AtorJogador1 -> AtorJogador1: enviarJogada(ATUALIZARTABULEIRO)
    AtorJogador1 -> NetworkService1: enviarJogada(jogada)
    NetworkService1 -> Proxy1: enviaJogada(jogada)
    Proxy1 -> Server: enviaJogada(jogada)
    
    Server -> Partida: efetuaJogada(jogador1, jogada)
    Partida -> ServerHandler2: recebeJogada(jogada)
    
    ServerHandler2 -> Proxy2: recebeJogada(jogada)
    Proxy2 -> NetworkService2: receberJogada(jogada)
    NetworkService2 -> GameEventHandler2: receberJogada(jogada)
    note right: Interface-based communication
    GameEventHandler2 -> AtorJogador2: receberJogada(jogada)
    AtorJogador2 -> AtorJogador2: atualizaTabuleiro(tabuleiro)
    AtorJogador2 -> TabuleiroService2: atualizarTabuleiro(tabuleiro)
    note right: Service updates game state
end

== Error Handling (Improved) ==

alt network error
    NetworkService1 -> GameEventHandler1: notificar("Erro de rede")
    note right: Clean error propagation via interface
    GameEventHandler1 -> AtorJogador1: notificar("Erro de rede")
end

alt game logic error
    TabuleiroService1 -> TabuleiroService1: handle error internally
    note right: Service handles its own errors
    TabuleiroService1 --> AtorJogador1: return false/error state
end

note over AtorJogador1, AtorJogador2
**Key Improvements in Refactored Architecture:**
• No circular dependencies
• Clean interface-based communication
• Services handle their own responsibilities
• Error handling is localized
• Easy to test and maintain
end note

@enduml